# æŠ€èƒ½ç³»ç»Ÿé›†æˆç¤ºä¾‹

## ğŸ“‹ å¿«é€Ÿå¼€å§‹

### 1. åœ¨GameSceneä¸­åˆå§‹åŒ–

```typescript
import { SkillSystem } from '@/game/systems/SkillSystem';
import { getAllFireSkills } from '@/data/skills/fireSkills';

export class GameScene extends Phaser.Scene {
  private skillSystem!: SkillSystem;
  private player: any;

  create() {
    // åˆå§‹åŒ–æŠ€èƒ½ç³»ç»Ÿ
    this.skillSystem = new SkillSystem(this);

    // ç›‘å¬æŠ€èƒ½äº‹ä»¶
    this.setupSkillEvents();
  }

  private setupSkillEvents() {
    // å¼¹é“æŠ€èƒ½ç¢°æ’æ£€æµ‹
    this.events.on('skill-projectile-created', ({ projectile, skill, caster }) => {
      // æ·»åŠ ä¸æ•Œäººçš„ç¢°æ’æ£€æµ‹
      this.physics.add.overlap(
        projectile,
        this.enemyGroup,
        (proj, enemy: any) => {
          enemy.takeDamage(skill.damage || 0);
          proj.destroy();
        }
      );
    });

    // èŒƒå›´æŠ€èƒ½ä¼¤å®³
    this.events.on('skill-area-damage', ({ x, y, radius, damage }) => {
      // æ£€æµ‹èŒƒå›´å†…çš„æ•Œäºº
      this.enemyGroup.getChildren().forEach((enemy: any) => {
        const distance = Phaser.Math.Distance.Between(x, y, enemy.x, enemy.y);
        if (distance <= radius) {
          enemy.takeDamage(damage || 0);
        }
      });
    });

    // æ²»ç–—æŠ€èƒ½
    this.events.on('skill-heal', ({ target, amount }) => {
      target.hp = Math.min(target.maxHp, target.hp + amount);
    });

    // å¢ç›ŠæŠ€èƒ½
    this.events.on('skill-buff', ({ target, type, value, duration }) => {
      // åº”ç”¨buffæ•ˆæœ
      console.log(`Applied ${type} buff: +${value} for ${duration}ms`);
    });
  }
}
```

### 2. é‡Šæ”¾æŠ€èƒ½

```typescript
// è·å–æŠ€èƒ½æ•°æ®
const fireSkills = getAllFireSkills();
const fireball = fireSkills[0]; // ç«çƒæœ¯

// æ£€æŸ¥æ˜¯å¦å¯ä»¥é‡Šæ”¾
if (this.skillSystem.canCastSkill(fireball, player.mp)) {
  // è·å–ç›®æ ‡ä½ç½®ï¼ˆé¼ æ ‡ä½ç½®æˆ–æ•Œäººä½ç½®ï¼‰
  const target = {
    x: this.input.activePointer.worldX,
    y: this.input.activePointer.worldY,
  };

  // é‡Šæ”¾æŠ€èƒ½
  this.skillSystem.castSkill(fireball, player, target);

  // æ‰£é™¤é­”åŠ›
  player.mp -= fireball.manaCost;
}
```

### 3. åœ¨UIä¸­æ˜¾ç¤ºæŠ€èƒ½

```tsx
import { SkillTree } from '@/ui/components/SkillTree';
import { SkillHotbar } from '@/ui/components/SkillHotbar';

function GameUI() {
  const [showSkillTree, setShowSkillTree] = useState(false);
  const [equippedSkills, setEquippedSkills] = useState<Skill[]>([]);

  const handleCastSkill = (skill: Skill) => {
    // é€šçŸ¥Phaseråœºæ™¯é‡Šæ”¾æŠ€èƒ½
    game.scene.scenes[0].events.emit('cast-skill', skill);
  };

  return (
    <>
      {/* æŠ€èƒ½å¿«æ·æ  */}
      <SkillHotbar
        skills={equippedSkills}
        onCastSkill={handleCastSkill}
      />

      {/* æŠ€èƒ½æ ‘ç•Œé¢ */}
      {showSkillTree && <SkillTree />}

      {/* æ‰“å¼€æŠ€èƒ½æ ‘æŒ‰é’® */}
      <button onClick={() => setShowSkillTree(true)}>
        Skills (K)
      </button>
    </>
  );
}
```

## ğŸ¯ å®Œæ•´ç¤ºä¾‹ï¼šç®€å•æˆ˜æ–—åœºæ™¯

```typescript
export class BattleScene extends Phaser.Scene {
  private skillSystem!: SkillSystem;
  private player!: Phaser.GameObjects.Sprite;
  private enemies!: Phaser.Physics.Arcade.Group;
  private equippedSkills: Skill[] = [];

  create() {
    this.skillSystem = new SkillSystem(this);

    // åˆ›å»ºç©å®¶
    this.player = this.physics.add.sprite(400, 300, 'hero');
    (this.player as any).mp = 100;
    (this.player as any).maxMp = 100;

    // åˆ›å»ºæ•Œäººç»„
    this.enemies = this.physics.add.group();

    // è£…å¤‡æŠ€èƒ½
    const fireSkills = getAllFireSkills();
    const waterSkills = getAllWaterSkills();
    this.equippedSkills = [
      fireSkills[0], // ç«çƒæœ¯
      waterSkills[0], // æ²»ç–—æœ¯
      fireSkills[1], // ç«å¢™æœ¯
    ];

    // è®¾ç½®é”®ç›˜è¾“å…¥
    this.setupInput();

    // è®¾ç½®æŠ€èƒ½äº‹ä»¶
    this.setupSkillEvents();
  }

  private setupInput() {
    // 1-6é”®é‡Šæ”¾æŠ€èƒ½
    this.input.keyboard?.on('keydown-ONE', () => this.castSkillByIndex(0));
    this.input.keyboard?.on('keydown-TWO', () => this.castSkillByIndex(1));
    this.input.keyboard?.on('keydown-THREE', () => this.castSkillByIndex(2));

    // é¼ æ ‡ç‚¹å‡»é‡Šæ”¾æŠ€èƒ½
    this.input.on('pointerdown', (pointer: Phaser.Input.Pointer) => {
      if (pointer.leftButtonDown()) {
        this.castSkillByIndex(0); // é»˜è®¤é‡Šæ”¾ç¬¬ä¸€ä¸ªæŠ€èƒ½
      }
    });
  }

  private castSkillByIndex(index: number) {
    const skill = this.equippedSkills[index];
    if (!skill) return;

    const playerData = this.player as any;

    if (this.skillSystem.canCastSkill(skill, playerData.mp)) {
      const target = {
        x: this.input.activePointer.worldX,
        y: this.input.activePointer.worldY,
      };

      this.skillSystem.castSkill(skill, this.player, target);
      playerData.mp -= skill.manaCost;

      console.log(`Cast ${skill.name}, MP: ${playerData.mp}/${playerData.maxMp}`);
    } else {
      console.log('Not enough mana or skill on cooldown!');
    }
  }

  private setupSkillEvents() {
    // å¼¹é“ç¢°æ’
    this.events.on('skill-projectile-created', ({ projectile, skill }) => {
      this.physics.add.overlap(
        projectile,
        this.enemies,
        (proj, enemy: any) => {
          enemy.takeDamage?.(skill.damage || 0);
          proj.destroy();

          // å‡»ä¸­ç‰¹æ•ˆ
          const hit = this.add.circle(enemy.x, enemy.y, 20, 0xffffff, 0.8);
          hit.setBlendMode(Phaser.BlendModes.ADD);
          this.tweens.add({
            targets: hit,
            scale: 2,
            alpha: 0,
            duration: 200,
            onComplete: () => hit.destroy(),
          });
        }
      );
    });

    // èŒƒå›´ä¼¤å®³
    this.events.on('skill-area-damage', ({ x, y, radius, damage }) => {
      this.enemies.getChildren().forEach((enemy: any) => {
        const dist = Phaser.Math.Distance.Between(x, y, enemy.x, enemy.y);
        if (dist <= radius) {
          enemy.takeDamage?.(damage || 0);
        }
      });
    });

    // æ²»ç–—
    this.events.on('skill-heal', ({ amount }) => {
      const playerData = this.player as any;
      playerData.hp = Math.min(playerData.maxHp || 100, (playerData.hp || 100) + amount);
      console.log(`Healed ${amount} HP!`);
    });
  }

  update() {
    // é­”åŠ›è‡ªç„¶æ¢å¤
    const playerData = this.player as any;
    playerData.mp = Math.min(playerData.maxMp, playerData.mp + 0.1);
  }
}
```

## ğŸ”§ é«˜çº§ç”¨æ³•

### æŠ€èƒ½å†·å´æ˜¾ç¤º

```typescript
// è·å–æŠ€èƒ½å†·å´è¿›åº¦
const progress = this.skillSystem.getCooldownProgress(
  skill.id,
  skill.cooldown
);

// åœ¨UIä¸­æ˜¾ç¤ºï¼ˆ0-1ï¼Œ1è¡¨ç¤ºå¯ç”¨ï¼‰
if (progress < 1) {
  console.log(`Skill cooldown: ${((1 - progress) * 100).toFixed(0)}%`);
}
```

### æŠ€èƒ½è¿å‡»ç³»ç»Ÿ

```typescript
private lastSkillTime = 0;
private comboCount = 0;

private castSkillWithCombo(skill: Skill, target: any) {
  const now = this.time.now;
  
  // æ£€æµ‹è¿å‡»
  if (now - this.lastSkillTime < 1000) {
    this.comboCount++;
    console.log(`Combo x${this.comboCount}!`);
  } else {
    this.comboCount = 1;
  }

  this.lastSkillTime = now;
  this.skillSystem.castSkill(skill, this.player, target);
}
```

### æŠ€èƒ½æ•ˆæœå åŠ 

```typescript
private activeBuffs: Map<string, { value: number; endTime: number }> = new Map();

private applyBuff(type: string, value: number, duration: number) {
  const endTime = this.time.now + duration;
  
  // å åŠ æˆ–åˆ·æ–°buff
  const existing = this.activeBuffs.get(type);
  if (existing) {
    existing.value += value;
    existing.endTime = Math.max(existing.endTime, endTime);
  } else {
    this.activeBuffs.set(type, { value, endTime });
  }
}

update() {
  // æ¸…ç†è¿‡æœŸbuff
  const now = this.time.now;
  this.activeBuffs.forEach((buff, type) => {
    if (now >= buff.endTime) {
      this.activeBuffs.delete(type);
      console.log(`Buff expired: ${type}`);
    }
  });
}
```

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **å¯¹è±¡æ± **: å¯¹äºé¢‘ç¹åˆ›å»ºçš„å¼¹é“ï¼Œä½¿ç”¨å¯¹è±¡æ± 
2. **äº‹ä»¶æ¸…ç†**: åŠæ—¶ç§»é™¤äº‹ä»¶ç›‘å¬å™¨
3. **ç²’å­é™åˆ¶**: é™åˆ¶åŒæ—¶å­˜åœ¨çš„ç²’å­æ•°é‡
4. **LOD**: è¿œè·ç¦»æŠ€èƒ½ç‰¹æ•ˆç®€åŒ–

## ğŸ¨ è‡ªå®šä¹‰æŠ€èƒ½ç‰¹æ•ˆ

```typescript
// åœ¨ProjectileEffect.tsä¸­æ·»åŠ è‡ªå®šä¹‰æŠ€èƒ½
createCustomSkill(caster: any, target: any, skill: Skill): void {
  // ä½ çš„è‡ªå®šä¹‰ç‰¹æ•ˆä»£ç 
  const color = 0xff00ff;
  const projectile = this.create(caster, target, skill, color);
  
  // æ·»åŠ ç‰¹æ®ŠåŠ¨ç”»
  this.scene.tweens.add({
    targets: projectile,
    scale: { from: 1, to: 2 },
    duration: 500,
    yoyo: true,
    repeat: -1,
  });
}
```

---

æ›´å¤šè¯¦æƒ…è¯·å‚è€ƒï¼š
- `frontend/src/game/systems/SkillSystem.ts` - ä¸»ç³»ç»Ÿ
- `frontend/src/game/systems/effects/` - ç‰¹æ•ˆæ¨¡å—
- `frontend/src/ui/components/SkillTree.tsx` - UIç»„ä»¶
