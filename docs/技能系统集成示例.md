# 技能系统集成示例

## 📋 快速开始

### 1. 在GameScene中初始化

```typescript
import { SkillSystem } from '@/game/systems/SkillSystem';
import { getAllFireSkills } from '@/data/skills/fireSkills';

export class GameScene extends Phaser.Scene {
  private skillSystem!: SkillSystem;
  private player: any;

  create() {
    // 初始化技能系统
    this.skillSystem = new SkillSystem(this);

    // 监听技能事件
    this.setupSkillEvents();
  }

  private setupSkillEvents() {
    // 弹道技能碰撞检测
    this.events.on('skill-projectile-created', ({ projectile, skill, caster }) => {
      // 添加与敌人的碰撞检测
      this.physics.add.overlap(
        projectile,
        this.enemyGroup,
        (proj, enemy: any) => {
          enemy.takeDamage(skill.damage || 0);
          proj.destroy();
        }
      );
    });

    // 范围技能伤害
    this.events.on('skill-area-damage', ({ x, y, radius, damage }) => {
      // 检测范围内的敌人
      this.enemyGroup.getChildren().forEach((enemy: any) => {
        const distance = Phaser.Math.Distance.Between(x, y, enemy.x, enemy.y);
        if (distance <= radius) {
          enemy.takeDamage(damage || 0);
        }
      });
    });

    // 治疗技能
    this.events.on('skill-heal', ({ target, amount }) => {
      target.hp = Math.min(target.maxHp, target.hp + amount);
    });

    // 增益技能
    this.events.on('skill-buff', ({ target, type, value, duration }) => {
      // 应用buff效果
      console.log(`Applied ${type} buff: +${value} for ${duration}ms`);
    });
  }
}
```

### 2. 释放技能

```typescript
// 获取技能数据
const fireSkills = getAllFireSkills();
const fireball = fireSkills[0]; // 火球术

// 检查是否可以释放
if (this.skillSystem.canCastSkill(fireball, player.mp)) {
  // 获取目标位置（鼠标位置或敌人位置）
  const target = {
    x: this.input.activePointer.worldX,
    y: this.input.activePointer.worldY,
  };

  // 释放技能
  this.skillSystem.castSkill(fireball, player, target);

  // 扣除魔力
  player.mp -= fireball.manaCost;
}
```

### 3. 在UI中显示技能

```tsx
import { SkillTree } from '@/ui/components/SkillTree';
import { SkillHotbar } from '@/ui/components/SkillHotbar';

function GameUI() {
  const [showSkillTree, setShowSkillTree] = useState(false);
  const [equippedSkills, setEquippedSkills] = useState<Skill[]>([]);

  const handleCastSkill = (skill: Skill) => {
    // 通知Phaser场景释放技能
    game.scene.scenes[0].events.emit('cast-skill', skill);
  };

  return (
    <>
      {/* 技能快捷栏 */}
      <SkillHotbar
        skills={equippedSkills}
        onCastSkill={handleCastSkill}
      />

      {/* 技能树界面 */}
      {showSkillTree && <SkillTree />}

      {/* 打开技能树按钮 */}
      <button onClick={() => setShowSkillTree(true)}>
        Skills (K)
      </button>
    </>
  );
}
```

## 🎯 完整示例：简单战斗场景

```typescript
export class BattleScene extends Phaser.Scene {
  private skillSystem!: SkillSystem;
  private player!: Phaser.GameObjects.Sprite;
  private enemies!: Phaser.Physics.Arcade.Group;
  private equippedSkills: Skill[] = [];

  create() {
    this.skillSystem = new SkillSystem(this);

    // 创建玩家
    this.player = this.physics.add.sprite(400, 300, 'hero');
    (this.player as any).mp = 100;
    (this.player as any).maxMp = 100;

    // 创建敌人组
    this.enemies = this.physics.add.group();

    // 装备技能
    const fireSkills = getAllFireSkills();
    const waterSkills = getAllWaterSkills();
    this.equippedSkills = [
      fireSkills[0], // 火球术
      waterSkills[0], // 治疗术
      fireSkills[1], // 火墙术
    ];

    // 设置键盘输入
    this.setupInput();

    // 设置技能事件
    this.setupSkillEvents();
  }

  private setupInput() {
    // 1-6键释放技能
    this.input.keyboard?.on('keydown-ONE', () => this.castSkillByIndex(0));
    this.input.keyboard?.on('keydown-TWO', () => this.castSkillByIndex(1));
    this.input.keyboard?.on('keydown-THREE', () => this.castSkillByIndex(2));

    // 鼠标点击释放技能
    this.input.on('pointerdown', (pointer: Phaser.Input.Pointer) => {
      if (pointer.leftButtonDown()) {
        this.castSkillByIndex(0); // 默认释放第一个技能
      }
    });
  }

  private castSkillByIndex(index: number) {
    const skill = this.equippedSkills[index];
    if (!skill) return;

    const playerData = this.player as any;

    if (this.skillSystem.canCastSkill(skill, playerData.mp)) {
      const target = {
        x: this.input.activePointer.worldX,
        y: this.input.activePointer.worldY,
      };

      this.skillSystem.castSkill(skill, this.player, target);
      playerData.mp -= skill.manaCost;

      console.log(`Cast ${skill.name}, MP: ${playerData.mp}/${playerData.maxMp}`);
    } else {
      console.log('Not enough mana or skill on cooldown!');
    }
  }

  private setupSkillEvents() {
    // 弹道碰撞
    this.events.on('skill-projectile-created', ({ projectile, skill }) => {
      this.physics.add.overlap(
        projectile,
        this.enemies,
        (proj, enemy: any) => {
          enemy.takeDamage?.(skill.damage || 0);
          proj.destroy();

          // 击中特效
          const hit = this.add.circle(enemy.x, enemy.y, 20, 0xffffff, 0.8);
          hit.setBlendMode(Phaser.BlendModes.ADD);
          this.tweens.add({
            targets: hit,
            scale: 2,
            alpha: 0,
            duration: 200,
            onComplete: () => hit.destroy(),
          });
        }
      );
    });

    // 范围伤害
    this.events.on('skill-area-damage', ({ x, y, radius, damage }) => {
      this.enemies.getChildren().forEach((enemy: any) => {
        const dist = Phaser.Math.Distance.Between(x, y, enemy.x, enemy.y);
        if (dist <= radius) {
          enemy.takeDamage?.(damage || 0);
        }
      });
    });

    // 治疗
    this.events.on('skill-heal', ({ amount }) => {
      const playerData = this.player as any;
      playerData.hp = Math.min(playerData.maxHp || 100, (playerData.hp || 100) + amount);
      console.log(`Healed ${amount} HP!`);
    });
  }

  update() {
    // 魔力自然恢复
    const playerData = this.player as any;
    playerData.mp = Math.min(playerData.maxMp, playerData.mp + 0.1);
  }
}
```

## 🔧 高级用法

### 技能冷却显示

```typescript
// 获取技能冷却进度
const progress = this.skillSystem.getCooldownProgress(
  skill.id,
  skill.cooldown
);

// 在UI中显示（0-1，1表示可用）
if (progress < 1) {
  console.log(`Skill cooldown: ${((1 - progress) * 100).toFixed(0)}%`);
}
```

### 技能连击系统

```typescript
private lastSkillTime = 0;
private comboCount = 0;

private castSkillWithCombo(skill: Skill, target: any) {
  const now = this.time.now;
  
  // 检测连击
  if (now - this.lastSkillTime < 1000) {
    this.comboCount++;
    console.log(`Combo x${this.comboCount}!`);
  } else {
    this.comboCount = 1;
  }

  this.lastSkillTime = now;
  this.skillSystem.castSkill(skill, this.player, target);
}
```

### 技能效果叠加

```typescript
private activeBuffs: Map<string, { value: number; endTime: number }> = new Map();

private applyBuff(type: string, value: number, duration: number) {
  const endTime = this.time.now + duration;
  
  // 叠加或刷新buff
  const existing = this.activeBuffs.get(type);
  if (existing) {
    existing.value += value;
    existing.endTime = Math.max(existing.endTime, endTime);
  } else {
    this.activeBuffs.set(type, { value, endTime });
  }
}

update() {
  // 清理过期buff
  const now = this.time.now;
  this.activeBuffs.forEach((buff, type) => {
    if (now >= buff.endTime) {
      this.activeBuffs.delete(type);
      console.log(`Buff expired: ${type}`);
    }
  });
}
```

## 📊 性能优化建议

1. **对象池**: 对于频繁创建的弹道，使用对象池
2. **事件清理**: 及时移除事件监听器
3. **粒子限制**: 限制同时存在的粒子数量
4. **LOD**: 远距离技能特效简化

## 🎨 自定义技能特效

```typescript
// 在ProjectileEffect.ts中添加自定义技能
createCustomSkill(caster: any, target: any, skill: Skill): void {
  // 你的自定义特效代码
  const color = 0xff00ff;
  const projectile = this.create(caster, target, skill, color);
  
  // 添加特殊动画
  this.scene.tweens.add({
    targets: projectile,
    scale: { from: 1, to: 2 },
    duration: 500,
    yoyo: true,
    repeat: -1,
  });
}
```

---

更多详情请参考：
- `frontend/src/game/systems/SkillSystem.ts` - 主系统
- `frontend/src/game/systems/effects/` - 特效模块
- `frontend/src/ui/components/SkillTree.tsx` - UI组件
